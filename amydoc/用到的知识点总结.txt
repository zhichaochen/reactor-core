1、queue 和 deque的区别？
    deque：迪克，双向队列

    1、队列的常用操作
         	    抛出异常	        返回特殊值（null）
        插入	add(e)	        offer(e)
        移除	remove()	    poll()
        检查	element()	    peek()

        总结一下：常规的单词都是抛出异常，不常见的单词反倒是返回null。
    2、Queue常用方法：
        boolean add(E e);
            将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，
            如果当前没有可用的空间，则抛出 IllegalStateException。
        boolean offer(E e);
            将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，
            此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。
        E remove();获取并移除此队列的头。如果没有抛出异常
        E poll();获取并移除此队列的头，如果此队列为空，则返回 null。
            poll：也有获得的意思。
        E element();获取，但是不移除此队列的头。
        E peek();获取但不移除此队列的头；如果此队列为空，则返回 null。
            peek：偷窥，偷看的意思，只得到值，但是我并不取出。


    3、deque
        双向队列(Deque),是Queue的一个子接口
        双向队列是指该队列【两端的元素】【既能入队(offer)】【也能出队(poll)】,
        如果将Deque限制为只能从一端入队和出队，则可实现栈的数据结构。
        对于栈而言，有入栈(push)和出栈(pop)，遵循先进后出原则。

        一个线性 collection，支持在两端插入和移除元素。
        名称 deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”

        下表总结了上述 12 种方法：

                第一个元素（头部）	            最后一个元素（尾部）
                抛出异常	特殊值	                抛出异常	特殊值
        插入	addFirst(e)	offerFirst(e)	    addLast(e)	offerLast(e)
        移除	removeFirst()	pollFirst()	    removeLast()	pollLast()
        检查	getFirst()	peekFirst()	        getLast()	peekLast()


        双端队列也可用作 LIFO（后进先出）堆栈。应优先使用此接口而不是遗留 Stack 类。
        在将双端队列用作堆栈时，元素被推入双端队列的开头并从双端队列开头弹出。
        堆栈方法完全等效于 Deque 方法，如下表所示：

        堆栈方法	等效 Deque 方法
        push(e)	addFirst(e)
        pop()	removeFirst()
        peek()	peekFirst()

2、SpscLinkedArrayQueue
    SpscLinkedArrayQueue的数据结构主要神奇在它既不是传统的数组，又不是传统的链表，而是数组+链表。

3、Future.cancel(boolean)
    用于取消异步的任务，它传入一个boolean类型的参数，表示是否要终止正在执行的任务。
    传入true会中断线程并停止正在执行的任务。
    传入false则会让线程正常执行至完成，然后取消该线程。

    创建了Future实例，任务有以下三种状态：
        1、等待状态
            此时调用cancel()方法不管传入true还是false都会标记为取消，任务依然保存在任务队列中，但当轮到此任务运行时会直接跳过。
        2、完成状态
            此时cancel()不会起任何作用，因为任务已经完成了。
        3、正在运行中
            传入true打断当前正在执行的任务，传入false让当前线程执行完毕，在打断当前线程

    1、实战（WorkerTask#setFuture）
        boolean async = thread != Thread.currentThread();
        if (FUTURE.compareAndSet(this, f, async ? ASYNC_CANCELLED : SYNC_CANCELLED)) {
        	if (f != null) {
        		f.cancel(async);
        	}
        	break;
        }
	    其中：SYNC_CANCELLED，表示在同一个线程中取消
	    ASYNC_CANCELLED：表示在另一个线程中取消

	    1、问题
	        为啥同步状态 设置为cancel(false)，异步状态设置为f.cancel(true)。
	    2、知识点
	        这里用到了打断一个线程的知识点。
	        如果线程进入阻塞状态的时候，会终止正在运行的
	    3、解答
	        因为在同一个线程中，你设置true也是不起作用的，也会等到任务执行完毕，线程才关闭。

	        一个线程进入了另一个线程中，说明当前线程被阻塞了。
	        设置cancel(true)，是可以结束一个正在运行的线程。

3、compareAndSet()
    在AtomicInteger.java里，CAS是这么被实际应用的，就拿里头的自增函数来说：

    public final int incrementAndGet() {
        for (;;) {
            int current = get();
            int next = current + 1;
            if (compareAndSet(current, next))
                return next;
        }
    }

    就是在native函数里，判断当前对象和期望的expect（也就是前面的current）是否一致，如果一致则返回true
    public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    }

    我的总结：
        就是轮询compareAndSet方法。
        如果某个值变成了期望的值，那么就返回true。
        比如：我执行1 + 1

        我期望是2，如果去更新的值变成2了，那么就返回true。

    故而：WorkerTask中如下代码可以理解。
        如果当前类中【f 对象】 变成了 【FINISHED 对象】，返回true。
        if (f == SYNC_CANCELLED || f == ASYNC_CANCELLED || FUTURE.compareAndSet(this, f, FINISHED)) {
    	    break;
    	}

4、






